import { describe, it, expect, vi, beforeEach } from 'vitest';
import fc from 'fast-check';
import { NostrCompatibilityService, NostrRelayValidator } from '../nostr-compatibility';
import { DeepLinkHandler } from '../deep-link-handler';
import { URLSchemeHandler } from '../url-scheme-handler';
import type { QRInviteData, ShareableProfile, InviteLink } from '../types';
import type { PublicKeyHex } from '@dweb/crypto';

// Mock dependencies
vi.mock('../crypto/crypto-service', () => ({
  cryptoService: {
    generateInviteId: vi.fn(() => 'mock-invite-id'),
    signInviteData: vi.fn(() => Promise.resolve('mock-signature')),
    verifyInviteSignature: vi.fn(() => Promise.resolve(true)),
    normalizeKey: vi.fn((key: string) => key),
    isValidPubkey: vi.fn(() => true)
  }
}));

vi.mock('../invite-manager', () => ({
  inviteManager: {
    processQRInvite: vi.fn(),
    processInviteLink: vi.fn(),
    sendContactRequest: vi.fn()
  }
}));

// Helper generators
const hexString = (length: number) => fc.string({ minLength: length, maxLength: length })
  .filter(s => /^[0-9a-fA-F]*$/.test(s))
  .map(s => s.padEnd(length, '0').slice(0, length));

const publicKeyGen = () => fc.string({ minLength: 64, maxLength: 64 }).map(s => 
  s.split('').map(c => /[0-9a-fA-F]/.test(c) ? c : '0').join('')
);
const shortCodeGen = () => fc.string({ minLength: 8, maxLength: 8 });

describe('Cross-Platform Compatibility Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  /**
   * Property 22: Cross-Platform Format Compatibility
   * For any invite generated by the system, it should conform to standardized Nostr formats 
   * compatible with other clients
   * Validates: Requirements 8.1, 8.2
   */
  describe('Property 22: Cross-Platform Format Compatibility', () => {
    it('should generate Nostr-compatible formats for all QR invites', async () => {
      await fc.assert(fc.asyncProperty(
        fc.record({
          publicKey: publicKeyGen(),
          displayName: fc.option(fc.string({ minLength: 1, maxLength: 50 })),
          avatar: fc.option(fc.webUrl()),
          message: fc.option(fc.string({ minLength: 1, maxLength: 200 })),
          timestamp: fc.integer({ min: Date.now() - 86400000, max: Date.now() }),
          expirationTime: fc.integer({ min: Date.now(), max: Date.now() + 86400000 }),
          signature: fc.string({ minLength: 10, maxLength: 100 })
        }),
        async (qrData) => {
          const typedQrData: QRInviteData = {
            version: '1.0',
            publicKey: qrData.publicKey as PublicKeyHex,
            displayName: qrData.displayName,
            avatar: qrData.avatar,
            message: qrData.message,
            timestamp: qrData.timestamp,
            expirationTime: qrData.expirationTime,
            signature: qrData.signature
          };

          // Convert to Nostr format
          const nostrFormat = NostrCompatibilityService.toNostrFormat(typedQrData);

          // Verify Nostr format structure
          expect(nostrFormat).toHaveProperty('version');
          expect(nostrFormat).toHaveProperty('type', 'qr');
          expect(nostrFormat).toHaveProperty('publicKey', qrData.publicKey);
          expect(nostrFormat).toHaveProperty('signature', qrData.signature);

          // Verify round-trip compatibility
          const convertedBack = NostrCompatibilityService.fromNostrFormat(nostrFormat);
          expect(convertedBack.publicKey).toBe(qrData.publicKey);
          expect(convertedBack.signature).toBe(qrData.signature);
          // Handle null vs undefined for optional fields
          expect(convertedBack.displayName || null).toBe(qrData.displayName || null);
        }
      ), { numRuns: 10 });
    });

    it('should parse external Nostr client formats correctly', async () => {
      await fc.assert(fc.asyncProperty(
        fc.record({
          pubkey: publicKeyGen(),
          kind: fc.constantFrom(0, 3, 30078),
          content: fc.string(),
          sig: fc.string({ minLength: 10, maxLength: 100 }),
          created_at: fc.integer({ min: 1000000000, max: Math.floor(Date.now() / 1000) })
        }),
        async (externalFormat) => {
          // Test parsing external formats
          const parsed = NostrCompatibilityService.parseExternalInvite(JSON.stringify(externalFormat));
          
          if (parsed) {
            // Should have valid structure
            expect(parsed).toHaveProperty('version');
            expect(parsed).toHaveProperty('publicKey');
            expect(parsed).toHaveProperty('signature');
            expect(['qr', 'link']).toContain(parsed.type);
          }
          
          // Should not throw errors for any input
          expect(() => NostrCompatibilityService.parseExternalInvite(JSON.stringify(externalFormat))).not.toThrow();
        }
      ), { numRuns: 10 });
    });
  });

  /**
   * Property 23: Universal Link Generation
   * For any invite link, it should be formatted as a universal link that works across 
   * web, mobile, and desktop platforms
   * Validates: Requirements 8.3
   */
  describe('Property 23: Universal Link Generation', () => {
    it('should generate universal links with all required platform URLs', async () => {
      await fc.assert(fc.asyncProperty(
        fc.record({
          id: fc.string({ minLength: 1, maxLength: 50 }),
          shortCode: shortCodeGen(),
          createdBy: publicKeyGen(),
          profile: fc.record({
            publicKey: publicKeyGen(),
            displayName: fc.option(fc.string({ minLength: 1, maxLength: 50 })),
            avatar: fc.option(fc.webUrl()),
            timestamp: fc.integer({ min: 1000000000, max: Date.now() }),
            signature: fc.string({ minLength: 10, maxLength: 100 })
          }),
          message: fc.option(fc.string({ minLength: 1, maxLength: 200 })),
          isActive: fc.boolean(),
          createdAt: fc.date()
        }),
        async (inviteLinkData) => {
          const inviteLink: InviteLink = {
            ...inviteLinkData,
            url: `https://obscur.app/invite/${inviteLinkData.shortCode}`,
            createdBy: inviteLinkData.createdBy as PublicKeyHex,
            profile: {
              ...inviteLinkData.profile,
              publicKey: inviteLinkData.profile.publicKey as PublicKeyHex
            },
            currentUses: 0
          };

          // Generate universal link
          const universalLink = NostrCompatibilityService.generateUniversalLink(inviteLink);

          // Verify all required URLs are present
          expect(universalLink).toHaveProperty('url');
          expect(universalLink).toHaveProperty('fallbackUrl');
          expect(universalLink).toHaveProperty('appScheme');
          expect(universalLink).toHaveProperty('webUrl');
          expect(universalLink).toHaveProperty('data');

          // Verify URL formats
          expect(universalLink.url).toMatch(/^https:\/\/obscur\.app\/invite\//);
          expect(universalLink.fallbackUrl).toMatch(/^https:\/\/obscur\.app\/invite\/.*\?fallback=true$/);
          expect(universalLink.appScheme).toMatch(/^obscur:\/\/invite\//);
          expect(universalLink.webUrl).toMatch(/^https:\/\/obscur\.app\/web\/invite\//);

          // Verify data structure
          expect(universalLink.data).toHaveProperty('version');
          expect(universalLink.data).toHaveProperty('type', 'link');
          expect(universalLink.data).toHaveProperty('publicKey');
        }
      ), { numRuns: 10 });
    });

    it('should generate consistent URLs for the same invite data', async () => {
      await fc.assert(fc.asyncProperty(
        fc.record({
          shortCode: shortCodeGen(),
          publicKey: publicKeyGen(),
          displayName: fc.option(fc.string({ minLength: 1, maxLength: 50 }))
        }),
        async (data) => {
          const inviteLink: InviteLink = {
            id: 'test-id',
            url: `https://obscur.app/invite/${data.shortCode}`,
            shortCode: data.shortCode,
            createdBy: data.publicKey as PublicKeyHex,
            profile: {
              publicKey: data.publicKey as PublicKeyHex,
              displayName: data.displayName,
              timestamp: Date.now(),
              signature: 'test-signature'
            },
            currentUses: 0,
            isActive: true,
            createdAt: new Date()
          };

          // Generate universal link twice
          const universalLink1 = NostrCompatibilityService.generateUniversalLink(inviteLink);
          const universalLink2 = NostrCompatibilityService.generateUniversalLink(inviteLink);

          // Should generate identical URLs
          expect(universalLink1.url).toBe(universalLink2.url);
          expect(universalLink1.fallbackUrl).toBe(universalLink2.fallbackUrl);
          expect(universalLink1.appScheme).toBe(universalLink2.appScheme);
          expect(universalLink1.webUrl).toBe(universalLink2.webUrl);
        }
      ), { numRuns: 10 });
    });
  });

  /**
   * Property 24: Deep Link Routing
   * For any valid deep link, the system should route users to the appropriate application section
   * Validates: Requirements 8.5
   */
  describe('Property 24: Deep Link Routing', () => {
    it('should correctly parse and route all supported deep link formats', async () => {
      await fc.assert(fc.asyncProperty(
        fc.oneof(
          // Obscur app scheme URLs
          fc.record({
            type: fc.constant('obscur'),
            path: fc.oneof(
              fc.tuple(fc.constant('invite'), shortCodeGen()),
              fc.tuple(fc.constant('contact'), publicKeyGen()),
              fc.tuple(fc.constant('qr'), fc.string({ minLength: 10, maxLength: 200 }))
            )
          }),
          // Nostr protocol URLs
          fc.record({
            type: fc.constant('nostr'),
            data: fc.oneof(
              publicKeyGen(),
              fc.string({ minLength: 10, maxLength: 100 }).map(s => `npub1${s}`)
            )
          }),
          // Web URLs
          fc.record({
            type: fc.constant('web'),
            path: fc.oneof(
              fc.tuple(fc.constant('invite'), shortCodeGen()),
              fc.tuple(fc.constant('connect'), publicKeyGen())
            ),
            fallback: fc.boolean()
          })
        ),
        async (linkData) => {
          let url: string;
          
          // Generate URL based on type
          switch (linkData.type) {
            case 'obscur':
              url = `obscur://${linkData.path[0]}/${linkData.path[1]}`;
              break;
            case 'nostr':
              url = `nostr:${linkData.data}`;
              break;
            case 'web':
              const fallbackParam = linkData.fallback ? '?fallback=true' : '';
              url = `https://obscur.app/${linkData.path[0]}/${linkData.path[1]}${fallbackParam}`;
              break;
            default:
              url = 'https://obscur.app/';
          }

          // Parse the deep link
          const route = DeepLinkHandler.parseDeepLink(url);

          // Should successfully parse supported formats
          if (linkData.type === 'obscur' || linkData.type === 'web') {
            // Only expect successful parsing if the path components are valid (no special chars that break parsing)
            const isValidPath = linkData.path[1] && 
              linkData.path[1].trim().length > 0 && 
              !/[%<>]/.test(linkData.path[1]); // Exclude problematic characters
            
            if (isValidPath) {
              expect(route.type).not.toBe('unknown');
              
              if (linkData.path[0] === 'invite') {
                expect(route.type).toBe('invite');
                // For web URLs, the shortCode might be URL encoded
                expect((route as any).shortCode).toBeDefined();
              } else if (linkData.path[0] === 'contact' || linkData.path[0] === 'connect') {
                expect(route.type).toBe('contact');
                // For web URLs, the publicKey might be URL encoded
                expect((route as any).publicKey).toBeDefined();
              }
            }
          }

          // Should handle fallback appropriately
          if (linkData.type === 'web' && 'fallback' in linkData) {
            if ('fallback' in route) {
              expect((route as any).fallback).toBe(linkData.fallback);
            }
          }

          // Should not throw errors for any valid input
          expect(() => DeepLinkHandler.parseDeepLink(url)).not.toThrow();
        }
      ), { numRuns: 10 });
    });

    it('should generate appropriate fallback URLs for all route types', async () => {
      await fc.assert(fc.asyncProperty(
        fc.oneof(
          fc.record({
            type: fc.constant('invite' as const),
            shortCode: shortCodeGen()
          }),
          fc.record({
            type: fc.constant('contact' as const),
            publicKey: publicKeyGen()
          }),
          fc.record({
            type: fc.constant('qr' as const),
            data: fc.string({ minLength: 10, maxLength: 200 })
          })
        ),
        async (route) => {
          // Generate fallback URLs
          const fallbackUrls = DeepLinkHandler.generateFallbackUrls(route);

          // Should have all required fallback URLs
          expect(fallbackUrls).toHaveProperty('webUrl');
          expect(fallbackUrls).toHaveProperty('installUrl');
          expect(fallbackUrls).toHaveProperty('universalUrl');

          // URLs should be valid
          expect(fallbackUrls.webUrl).toMatch(/^https:\/\/obscur\.app/);
          expect(fallbackUrls.installUrl).toMatch(/^https:\/\/obscur\.app\/install/);
          expect(fallbackUrls.universalUrl).toMatch(/^https:\/\/obscur\.app/);

          // URLs should contain route-specific information
          if (route.type === 'invite') {
            expect(fallbackUrls.webUrl).toContain(route.shortCode);
            expect(fallbackUrls.installUrl).toContain(route.shortCode);
            expect(fallbackUrls.universalUrl).toContain(route.shortCode);
          } else if (route.type === 'contact') {
            expect(fallbackUrls.webUrl).toContain(route.publicKey);
            expect(fallbackUrls.installUrl).toContain(route.publicKey);
            expect(fallbackUrls.universalUrl).toContain(route.publicKey);
          }
          // Note: QR type falls back to base URLs, which is expected behavior
        }
      ), { numRuns: 10 });
    });

    it('should handle malformed URLs gracefully without throwing errors', async () => {
      await fc.assert(fc.asyncProperty(
        fc.oneof(
          fc.string({ minLength: 1, maxLength: 200 }),
          fc.webUrl(),
          fc.string().map(s => `invalid://${s}`),
          fc.string().map(s => `obscur://${s}`),
          fc.string().map(s => `nostr:${s}`)
        ),
        async (malformedUrl) => {
          // Should not throw errors for any input
          expect(() => DeepLinkHandler.parseDeepLink(malformedUrl)).not.toThrow();
          
          // Should return a valid route object
          const route = DeepLinkHandler.parseDeepLink(malformedUrl);
          expect(route).toHaveProperty('type');
          expect(typeof route.type).toBe('string');
          
          // Should be able to generate fallback URLs even for unknown routes
          expect(() => DeepLinkHandler.generateFallbackUrls(route)).not.toThrow();
        }
      ), { numRuns: 10 });
    });
  });

  describe('Relay URL Validation', () => {
    it('should validate and normalize relay URLs correctly', async () => {
      await fc.assert(fc.asyncProperty(
        fc.oneof(
          fc.webUrl({ validSchemes: ['ws', 'wss'] }),
          fc.string().map(s => `ws://${s}`),
          fc.string().map(s => `wss://${s}`),
          fc.webUrl({ validSchemes: ['http', 'https'] }),
          fc.string()
        ),
        async (url) => {
          const result = NostrRelayValidator.validateRelayUrl(url);
          
          // Should always return a result object
          expect(result).toHaveProperty('isValid');
          expect(typeof result.isValid).toBe('boolean');
          
          if (result.isValid) {
            // Valid URLs should have normalized URL
            expect(result).toHaveProperty('normalizedUrl');
            expect(typeof result.normalizedUrl).toBe('string');
            
            // Should prefer secure connections
            if (result.normalizedUrl && !result.normalizedUrl.includes('localhost')) {
              expect(result.normalizedUrl).toMatch(/^wss:/);
            }
          } else {
            // Invalid URLs should have error message
            expect(result).toHaveProperty('error');
            expect(typeof result.error).toBe('string');
          }
        }
      ), { numRuns: 10 });
    });
  });
});

/**
 * Feature: smart-invite-system, Property 22: Cross-Platform Format Compatibility
 * Feature: smart-invite-system, Property 23: Universal Link Generation  
 * Feature: smart-invite-system, Property 24: Deep Link Routing
 */